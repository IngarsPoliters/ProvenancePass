{"version":3,"file":"index-DMB_In6n.js","sources":["../../../../node_modules/.pnpm/@noble+ed25519@2.3.0/node_modules/@noble/ed25519/index.js"],"sourcesContent":["/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\n/**\n * 4KB JS implementation of ed25519 EdDSA signatures.\n * Compliant with RFC8032, FIPS 186-5 & ZIP215.\n * @module\n * @example\n * ```js\nimport * as ed from '@noble/ed25519';\n(async () => {\n  const privKey = ed.utils.randomPrivateKey();\n  const message = Uint8Array.from([0xab, 0xbc, 0xcd, 0xde]);\n  const pubKey = await ed.getPublicKeyAsync(privKey); // Sync methods are also present\n  const signature = await ed.signAsync(message, privKey);\n  const isValid = await ed.verifyAsync(signature, message, pubKey);\n})();\n```\n */\n/**\n * Curve params. ed25519 is twisted edwards curve. Equation is −x² + y² = -a + dx²y².\n * * P = `2n**255n - 19n` // field over which calculations are done\n * * N = `2n**252n + 27742317777372353535851937790883648493n` // group order, amount of curve points\n * * h = 8 // cofactor\n * * a = `Fp.create(BigInt(-1))` // equation param\n * * d = -121665/121666 a.k.a. `Fp.neg(121665 * Fp.inv(121666))` // equation param\n * * Gx, Gy are coordinates of Generator / base point\n */\nconst ed25519_CURVE = {\n    p: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedn,\n    n: 0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3edn,\n    h: 8n,\n    a: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffecn,\n    d: 0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3n,\n    Gx: 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an,\n    Gy: 0x6666666666666666666666666666666666666666666666666666666666666658n,\n};\nconst { p: P, n: N, Gx, Gy, a: _a, d: _d } = ed25519_CURVE;\nconst h = 8n; // cofactor\nconst L = 32; // field / group byte length\nconst L2 = 64;\n// Helpers and Precomputes sections are reused between libraries\n// ## Helpers\n// ----------\n// error helper, messes-up stack trace\nconst err = (m = '') => {\n    throw new Error(m);\n};\nconst isBig = (n) => typeof n === 'bigint'; // is big integer\nconst isStr = (s) => typeof s === 'string'; // is string\nconst isBytes = (a) => a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n/** assert is Uint8Array (of specific length) */\nconst abytes = (a, l) => !isBytes(a) || (typeof l === 'number' && l > 0 && a.length !== l)\n    ? err('Uint8Array expected')\n    : a;\n/** create Uint8Array */\nconst u8n = (len) => new Uint8Array(len);\nconst u8fr = (buf) => Uint8Array.from(buf);\nconst padh = (n, pad) => n.toString(16).padStart(pad, '0');\nconst bytesToHex = (b) => Array.from(abytes(b))\n    .map((e) => padh(e, 2))\n    .join('');\nconst C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }; // ASCII characters\nconst _ch = (ch) => {\n    if (ch >= C._0 && ch <= C._9)\n        return ch - C._0; // '2' => 50-48\n    if (ch >= C.A && ch <= C.F)\n        return ch - (C.A - 10); // 'B' => 66-(65-10)\n    if (ch >= C.a && ch <= C.f)\n        return ch - (C.a - 10); // 'b' => 98-(97-10)\n    return;\n};\nconst hexToBytes = (hex) => {\n    const e = 'hex invalid';\n    if (!isStr(hex))\n        return err(e);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        return err(e);\n    const array = u8n(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        // treat each char as ASCII\n        const n1 = _ch(hex.charCodeAt(hi)); // parse first char, multiply it by 16\n        const n2 = _ch(hex.charCodeAt(hi + 1)); // parse second char\n        if (n1 === undefined || n2 === undefined)\n            return err(e);\n        array[ai] = n1 * 16 + n2; // example: 'A9' => 10*16 + 9\n    }\n    return array;\n};\n/** normalize hex or ui8a to ui8a */\nconst toU8 = (a, len) => abytes(isStr(a) ? hexToBytes(a) : u8fr(abytes(a)), len);\nconst cr = () => globalThis?.crypto; // WebCrypto is available in all modern environments\nconst subtle = () => cr()?.subtle ?? err('crypto.subtle must be defined');\n// prettier-ignore\nconst concatBytes = (...arrs) => {\n    const r = u8n(arrs.reduce((sum, a) => sum + abytes(a).length, 0)); // create u8a of summed length\n    let pad = 0; // walk through each array,\n    arrs.forEach(a => { r.set(a, pad); pad += a.length; }); // ensure they have proper type\n    return r;\n};\n/** WebCrypto OS-level CSPRNG (random number generator). Will throw when not available. */\nconst randomBytes = (len = L) => {\n    const c = cr();\n    return c.getRandomValues(u8n(len));\n};\nconst big = BigInt;\nconst arange = (n, min, max, msg = 'bad number: out of range') => isBig(n) && min <= n && n < max ? n : err(msg);\n/** modular division */\nconst M = (a, b = P) => {\n    const r = a % b;\n    return r >= 0n ? r : b + r;\n};\nconst modN = (a) => M(a, N);\n/** Modular inversion using eucledian GCD (non-CT). No negative exponent for now. */\n// prettier-ignore\nconst invert = (num, md) => {\n    if (num === 0n || md <= 0n)\n        err('no inverse n=' + num + ' mod=' + md);\n    let a = M(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;\n    while (a !== 0n) {\n        const q = b / a, r = b % a;\n        const m = x - u * q, n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    return b === 1n ? M(x, md) : err('no inverse'); // b is gcd at this point\n};\nconst callHash = (name) => {\n    // @ts-ignore\n    const fn = etc[name];\n    if (typeof fn !== 'function')\n        err('hashes.' + name + ' not set');\n    return fn;\n};\nconst apoint = (p) => (p instanceof Point ? p : err('Point expected'));\n// ## End of Helpers\n// -----------------\nconst B256 = 2n ** 256n;\n/** Point in XYZT extended coordinates. */\nclass Point {\n    static BASE;\n    static ZERO;\n    ex;\n    ey;\n    ez;\n    et;\n    constructor(ex, ey, ez, et) {\n        const max = B256;\n        this.ex = arange(ex, 0n, max);\n        this.ey = arange(ey, 0n, max);\n        this.ez = arange(ez, 1n, max);\n        this.et = arange(et, 0n, max);\n        Object.freeze(this);\n    }\n    static fromAffine(p) {\n        return new Point(p.x, p.y, 1n, M(p.x * p.y));\n    }\n    /** RFC8032 5.1.3: Uint8Array to Point. */\n    static fromBytes(hex, zip215 = false) {\n        const d = _d;\n        // Copy array to not mess it up.\n        const normed = u8fr(abytes(hex, L));\n        // adjust first LE byte = last BE byte\n        const lastByte = hex[31];\n        normed[31] = lastByte & ~0x80;\n        const y = bytesToNumLE(normed);\n        // zip215=true:           0 <= y < 2^256\n        // zip215=false, RFC8032: 0 <= y < 2^255-19\n        const max = zip215 ? B256 : P;\n        arange(y, 0n, max);\n        const y2 = M(y * y); // y²\n        const u = M(y2 - 1n); // u=y²-1\n        const v = M(d * y2 + 1n); // v=dy²+1\n        let { isValid, value: x } = uvRatio(u, v); // (uv³)(uv⁷)^(p-5)/8; square root\n        if (!isValid)\n            err('bad point: y not sqrt'); // not square root: bad point\n        const isXOdd = (x & 1n) === 1n; // adjust sign of x coordinate\n        const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n        if (!zip215 && x === 0n && isLastByteOdd)\n            err('bad point: x==0, isLastByteOdd'); // x=0, x_0=1\n        if (isLastByteOdd !== isXOdd)\n            x = M(-x);\n        return new Point(x, y, 1n, M(x * y)); // Z=1, T=xy\n    }\n    /** Checks if the point is valid and on-curve. */\n    assertValidity() {\n        const a = _a;\n        const d = _d;\n        const p = this;\n        if (p.is0())\n            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n        const { ex: X, ey: Y, ez: Z, et: T } = p;\n        const X2 = M(X * X); // X²\n        const Y2 = M(Y * Y); // Y²\n        const Z2 = M(Z * Z); // Z²\n        const Z4 = M(Z2 * Z2); // Z⁴\n        const aX2 = M(X2 * a); // aX²\n        const left = M(Z2 * M(aX2 + Y2)); // (aX² + Y²)Z²\n        const right = M(Z4 + M(d * M(X2 * Y2))); // Z⁴ + dX²Y²\n        if (left !== right)\n            throw new Error('bad point: equation left != right (1)');\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = M(X * Y);\n        const ZT = M(Z * T);\n        if (XY !== ZT)\n            throw new Error('bad point: equation left != right (2)');\n        return this;\n    }\n    /** Equality check: compare points P&Q. */\n    equals(other) {\n        const { ex: X1, ey: Y1, ez: Z1 } = this;\n        const { ex: X2, ey: Y2, ez: Z2 } = apoint(other); // checks class equality\n        const X1Z2 = M(X1 * Z2);\n        const X2Z1 = M(X2 * Z1);\n        const Y1Z2 = M(Y1 * Z2);\n        const Y2Z1 = M(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    is0() {\n        return this.equals(I);\n    }\n    /** Flip point over y coordinate. */\n    negate() {\n        return new Point(M(-this.ex), this.ey, this.ez, M(-this.et));\n    }\n    /** Point doubling. Complete formula. Cost: `4M + 4S + 1*a + 6add + 1*2`. */\n    double() {\n        const { ex: X1, ey: Y1, ez: Z1 } = this;\n        const a = _a;\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        const A = M(X1 * X1);\n        const B = M(Y1 * Y1);\n        const C = M(2n * M(Z1 * Z1));\n        const D = M(a * A);\n        const x1y1 = X1 + Y1;\n        const E = M(M(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = M(E * F);\n        const Y3 = M(G * H);\n        const T3 = M(E * H);\n        const Z3 = M(F * G);\n        return new Point(X3, Y3, Z3, T3);\n    }\n    /** Point addition. Complete formula. Cost: `8M + 1*k + 8add + 1*2`. */\n    add(other) {\n        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = apoint(other); // doesn't check if other on-curve\n        const a = _a;\n        const d = _d;\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3\n        const A = M(X1 * X2);\n        const B = M(Y1 * Y2);\n        const C = M(T1 * d * T2);\n        const D = M(Z1 * Z2);\n        const E = M((X1 + Y1) * (X2 + Y2) - A - B);\n        const F = M(D - C);\n        const G = M(D + C);\n        const H = M(B - a * A);\n        const X3 = M(E * F);\n        const Y3 = M(G * H);\n        const T3 = M(E * H);\n        const Z3 = M(F * G);\n        return new Point(X3, Y3, Z3, T3);\n    }\n    /**\n     * Point-by-scalar multiplication. Scalar must be in range 1 <= n < CURVE.n.\n     * Uses {@link wNAF} for base point.\n     * Uses fake point to mitigate side-channel leakage.\n     * @param n scalar by which point is multiplied\n     * @param safe safe mode guards against timing attacks; unsafe mode is faster\n     */\n    multiply(n, safe = true) {\n        if (!safe && (n === 0n || this.is0()))\n            return I;\n        arange(n, 1n, N);\n        if (n === 1n)\n            return this;\n        if (this.equals(G))\n            return wNAF(n).p;\n        // init result point & fake point\n        let p = I;\n        let f = G;\n        for (let d = this; n > 0n; d = d.double(), n >>= 1n) {\n            // if bit is present, add to point\n            // if not present, add to fake, for timing safety\n            if (n & 1n)\n                p = p.add(d);\n            else if (safe)\n                f = f.add(d);\n        }\n        return p;\n    }\n    /** Convert point to 2d xy affine point. (X, Y, Z) ∋ (x=X/Z, y=Y/Z) */\n    toAffine() {\n        const { ex: x, ey: y, ez: z } = this;\n        // fast-paths for ZERO point OR Z=1\n        if (this.equals(I))\n            return { x: 0n, y: 1n };\n        const iz = invert(z, P);\n        // (Z * Z^-1) must be 1, otherwise bad math\n        if (M(z * iz) !== 1n)\n            err('invalid inverse');\n        // x = X*Z^-1; y = Y*Z^-1\n        return { x: M(x * iz), y: M(y * iz) };\n    }\n    toBytes() {\n        const { x, y } = this.assertValidity().toAffine();\n        const b = numTo32bLE(y);\n        // store sign in first LE byte\n        b[31] |= x & 1n ? 0x80 : 0;\n        return b;\n    }\n    toHex() {\n        return bytesToHex(this.toBytes());\n    } // encode to hex string\n    clearCofactor() {\n        return this.multiply(big(h), false);\n    }\n    isSmallOrder() {\n        return this.clearCofactor().is0();\n    }\n    isTorsionFree() {\n        // multiply by big number CURVE.n\n        let p = this.multiply(N / 2n, false).double(); // ensures the point is not \"bad\".\n        if (N % 2n)\n            p = p.add(this); // P^(N+1) // P*N == (P*(N/2))*2+P\n        return p.is0();\n    }\n    static fromHex(hex, zip215) {\n        return Point.fromBytes(toU8(hex), zip215);\n    }\n    get x() {\n        return this.toAffine().x;\n    }\n    get y() {\n        return this.toAffine().y;\n    }\n    toRawBytes() {\n        return this.toBytes();\n    }\n}\n/** Generator / base point */\nconst G = new Point(Gx, Gy, 1n, M(Gx * Gy));\n/** Identity / zero point */\nconst I = new Point(0n, 1n, 1n, 0n);\n// Static aliases\nPoint.BASE = G;\nPoint.ZERO = I;\nconst numTo32bLE = (num) => hexToBytes(padh(arange(num, 0n, B256), L2)).reverse();\nconst bytesToNumLE = (b) => big('0x' + bytesToHex(u8fr(abytes(b)).reverse()));\nconst pow2 = (x, power) => {\n    // pow2(x, 4) == x^(2^4)\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n};\n// prettier-ignore\nconst pow_2_252_3 = (x) => {\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n};\nconst RM1 = 0x2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0n; // √-1\n// for sqrt comp\n// prettier-ignore\nconst uvRatio = (u, v) => {\n    const v3 = M(v * v * v); // v³\n    const v7 = M(v3 * v3 * v); // v⁷\n    const pow = pow_2_252_3(u * v7).pow_p_5_8; // (uv⁷)^(p-5)/8\n    let x = M(u * v3 * pow); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = M(v * x * x); // vx²\n    const root1 = x; // First root candidate\n    const root2 = M(x * RM1); // Second root candidate; RM1 is √-1\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === M(-u); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === M(-u * RM1); // There is no valid root, vx² = -u√-1\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if ((M(x) & 1n) === 1n)\n        x = M(-x); // edIsNegative\n    return { isValid: useRoot1 || useRoot2, value: x };\n};\n// N == L, just weird naming\nconst modL_LE = (hash) => modN(bytesToNumLE(hash)); // modulo L; but little-endian\nconst sha512a = (...m) => etc.sha512Async(...m); // Async SHA512\nconst sha512s = (...m) => callHash('sha512Sync')(...m);\n// RFC8032 5.1.5\nconst hash2extK = (hashed) => {\n    // slice creates a copy, unlike subarray\n    const head = hashed.slice(0, L);\n    head[0] &= 248; // Clamp bits: 0b1111_1000\n    head[31] &= 127; // 0b0111_1111\n    head[31] |= 64; // 0b0100_0000\n    const prefix = hashed.slice(L, L2); // private key \"prefix\"\n    const scalar = modL_LE(head); // modular division over curve order\n    const point = G.multiply(scalar); // public key point\n    const pointBytes = point.toBytes(); // point serialized to Uint8Array\n    return { head, prefix, scalar, point, pointBytes };\n};\n// RFC8032 5.1.5; getPublicKey async, sync. Hash priv key and extract point.\nconst getExtendedPublicKeyAsync = (priv) => sha512a(toU8(priv, L)).then(hash2extK);\nconst getExtendedPublicKey = (priv) => hash2extK(sha512s(toU8(priv, L)));\n/** Creates 32-byte ed25519 public key from 32-byte private key. Async. */\nconst getPublicKeyAsync = (priv) => getExtendedPublicKeyAsync(priv).then((p) => p.pointBytes);\n/** Creates 32-byte ed25519 public key from 32-byte private key. To use, set `etc.sha512Sync` first. */\nconst getPublicKey = (priv) => getExtendedPublicKey(priv).pointBytes;\nconst hashFinishA = (res) => sha512a(res.hashable).then(res.finish);\nconst hashFinishS = (res) => res.finish(sha512s(res.hashable));\nconst _sign = (e, rBytes, msg) => {\n    // sign() shared code\n    const { pointBytes: P, scalar: s } = e;\n    const r = modL_LE(rBytes); // r was created outside, reduce it modulo L\n    const R = G.multiply(r).toBytes(); // R = [r]B\n    const hashable = concatBytes(R, P, msg); // dom2(F, C) || R || A || PH(M)\n    const finish = (hashed) => {\n        // k = SHA512(dom2(F, C) || R || A || PH(M))\n        const S = modN(r + modL_LE(hashed) * s); // S = (r + k * s) mod L; 0 <= s < l\n        return abytes(concatBytes(R, numTo32bLE(S)), L2); // 64-byte sig: 32b R.x + 32b LE(S)\n    };\n    return { hashable, finish };\n};\n/**\n * Signs message (NOT message hash) using private key. Async.\n * Follows RFC8032 5.1.6.\n */\nconst signAsync = async (msg, privKey) => {\n    const m = toU8(msg);\n    const e = await getExtendedPublicKeyAsync(privKey);\n    const rBytes = await sha512a(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return hashFinishA(_sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\n/**\n * Signs message (NOT message hash) using private key. To use, set `hashes.sha512` first.\n * Follows RFC8032 5.1.6.\n */\nconst sign = (msg, privKey) => {\n    const m = toU8(msg);\n    const e = getExtendedPublicKey(privKey);\n    const rBytes = sha512s(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return hashFinishS(_sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\nconst veriOpts = { zip215: true };\nconst _verify = (sig, msg, pub, opts = veriOpts) => {\n    sig = toU8(sig, L2); // Signature hex str/Bytes, must be 64 bytes\n    msg = toU8(msg); // Message hex str/Bytes\n    pub = toU8(pub, L);\n    const { zip215 } = opts; // switch between zip215 and rfc8032 verif\n    let A;\n    let R;\n    let s;\n    let SB;\n    let hashable = Uint8Array.of();\n    try {\n        A = Point.fromHex(pub, zip215); // public key A decoded\n        R = Point.fromHex(sig.slice(0, L), zip215); // 0 <= R < 2^256: ZIP215 R can be >= P\n        s = bytesToNumLE(sig.slice(L, L2)); // Decode second half as an integer S\n        SB = G.multiply(s, false); // in the range 0 <= s < L\n        hashable = concatBytes(R.toBytes(), A.toBytes(), msg); // dom2(F, C) || R || A || PH(M)\n    }\n    catch (error) { }\n    const finish = (hashed) => {\n        // k = SHA512(dom2(F, C) || R || A || PH(M))\n        if (SB == null)\n            return false; // false if try-catch catched an error\n        if (!zip215 && A.isSmallOrder())\n            return false; // false for SBS: Strongly Binding Signature\n        const k = modL_LE(hashed); // decode in little-endian, modulo L\n        const RkA = R.add(A.multiply(k, false)); // [8]R + [8][k]A'\n        return RkA.add(SB.negate()).clearCofactor().is0(); // [8][S]B = [8]R + [8][k]A'\n    };\n    return { hashable, finish };\n};\n/** Verifies signature on message and public key. Async. Follows RFC8032 5.1.7. */\nconst verifyAsync = async (s, m, p, opts = veriOpts) => hashFinishA(_verify(s, m, p, opts));\n/** Verifies signature on message and public key. To use, set `hashes.sha512` first. Follows RFC8032 5.1.7. */\nconst verify = (s, m, p, opts = veriOpts) => hashFinishS(_verify(s, m, p, opts));\n/** Math, hex, byte helpers. Not in `utils` because utils share API with noble-curves. */\nconst etc = {\n    sha512Async: async (...messages) => {\n        const s = subtle();\n        const m = concatBytes(...messages);\n        return u8n(await s.digest('SHA-512', m.buffer));\n    },\n    sha512Sync: undefined,\n    bytesToHex: bytesToHex,\n    hexToBytes: hexToBytes,\n    concatBytes: concatBytes,\n    mod: M,\n    invert: invert,\n    randomBytes: randomBytes,\n};\n/** ed25519-specific key utilities. */\nconst utils = {\n    getExtendedPublicKeyAsync: getExtendedPublicKeyAsync,\n    getExtendedPublicKey: getExtendedPublicKey,\n    randomPrivateKey: () => randomBytes(L),\n    precompute: (w = 8, p = G) => {\n        p.multiply(3n);\n        w;\n        return p;\n    }, // no-op\n};\n// ## Precomputes\n// --------------\nconst W = 8; // W is window size\nconst scalarBits = 256;\nconst pwindows = Math.ceil(scalarBits / W) + 1; // 33 for W=8\nconst pwindowSize = 2 ** (W - 1); // 128 for W=8\nconst precompute = () => {\n    const points = [];\n    let p = G;\n    let b = p;\n    for (let w = 0; w < pwindows; w++) {\n        b = p;\n        points.push(b);\n        for (let i = 1; i < pwindowSize; i++) {\n            b = b.add(p);\n            points.push(b);\n        } // i=1, bc we skip 0\n        p = b.double();\n    }\n    return points;\n};\nlet Gpows = undefined; // precomputes for base point G\n// const-time negate\nconst ctneg = (cnd, p) => {\n    const n = p.negate();\n    return cnd ? n : p;\n};\n/**\n * Precomputes give 12x faster getPublicKey(), 10x sign(), 2x verify() by\n * caching multiples of G (base point). Cache is stored in 32MB of RAM.\n * Any time `G.multiply` is done, precomputes are used.\n * Not used for getSharedSecret, which instead multiplies random pubkey `P.multiply`.\n *\n * w-ary non-adjacent form (wNAF) precomputation method is 10% slower than windowed method,\n * but takes 2x less RAM. RAM reduction is possible by utilizing `.subtract`.\n *\n * !! Precomputes can be disabled by commenting-out call of the wNAF() inside Point#multiply().\n */\nconst wNAF = (n) => {\n    const comp = Gpows || (Gpows = precompute());\n    let p = I;\n    let f = G; // f must be G, or could become I in the end\n    const pow_2_w = 2 ** W; // 256 for W=8\n    const maxNum = pow_2_w; // 256 for W=8\n    const mask = big(pow_2_w - 1); // 255 for W=8 == mask 0b11111111\n    const shiftBy = big(W); // 8 for W=8\n    for (let w = 0; w < pwindows; w++) {\n        let wbits = Number(n & mask); // extract W bits.\n        n >>= shiftBy; // shift number by W bits.\n        if (wbits > pwindowSize) {\n            wbits -= maxNum;\n            n += 1n;\n        } // split if bits > max: +224 => 256-32\n        const off = w * pwindowSize;\n        const offF = off; // offsets, evaluate both\n        const offP = off + Math.abs(wbits) - 1;\n        const isEven = w % 2 !== 0; // conditions, evaluate both\n        const isNeg = wbits < 0;\n        if (wbits === 0) {\n            // off == I: can't add it. Adding random offF instead.\n            f = f.add(ctneg(isEven, comp[offF])); // bits are 0: add garbage to fake point\n        }\n        else {\n            p = p.add(ctneg(isNeg, comp[offP])); // bits are 1: add to result point\n        }\n    }\n    return { p, f }; // return both real and fake points for JIT\n};\n// !! Remove the export to easily use in REPL / browser console\nexport { ed25519_CURVE as CURVE, etc, Point as ExtendedPoint, getPublicKey, getPublicKeyAsync, Point, sign, signAsync, utils, verify, verifyAsync, };\n"],"names":["ed25519_CURVE","P","N","Gx","Gy","_a","_d","h","L","L2","err","m","isBig","n","isStr","s","isBytes","a","abytes","l","u8n","len","u8fr","buf","padh","pad","bytesToHex","b","e","C","_ch","ch","hexToBytes","hex","hl","al","array","ai","hi","n1","n2","toU8","cr","subtle","concatBytes","arrs","r","sum","randomBytes","big","arange","min","max","msg","M","modN","invert","num","md","x","u","q","callHash","name","fn","etc","apoint","p","Point","B256","_Point","ex","ey","ez","et","__publicField","zip215","d","normed","lastByte","y","bytesToNumLE","y2","v","isValid","uvRatio","isXOdd","isLastByteOdd","X","Y","Z","T","X2","Y2","Z2","Z4","aX2","left","right","XY","ZT","other","X1","Y1","Z1","X1Z2","X2Z1","Y1Z2","Y2Z1","I","A","B","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","T1","T2","safe","wNAF","z","iz","numTo32bLE","pow2","power","pow_2_252_3","b2","b4","b5","b10","b20","b40","b80","b160","b240","b250","RM1","v3","v7","pow","vx2","root1","root2","useRoot1","useRoot2","noRoot","modL_LE","hash","sha512a","sha512s","hash2extK","hashed","head","prefix","scalar","point","pointBytes","getExtendedPublicKeyAsync","priv","getExtendedPublicKey","getPublicKeyAsync","getPublicKey","hashFinishA","res","hashFinishS","_sign","rBytes","R","S","signAsync","privKey","sign","veriOpts","_verify","sig","pub","opts","SB","hashable","k","verifyAsync","verify","messages","utils","w","W","scalarBits","pwindows","pwindowSize","precompute","points","i","Gpows","ctneg","cnd","comp","f","pow_2_w","maxNum","mask","shiftBy","wbits","off","offF","offP","isEven","isNeg"],"mappings":"wKAAA,uEA0BK,MAACA,GAAgB,CAClB,EAAG,oEACH,EAAG,oEACH,EAAG,GACH,EAAG,oEACH,EAAG,oEACH,GAAI,oEACJ,GAAI,mEACR,EACM,CAAE,EAAGC,EAAG,EAAGC,EAAG,GAAAC,GAAI,GAAAC,GAAI,EAAGC,EAAI,EAAGC,CAAE,EAAKN,GACvCO,GAAI,GACJC,EAAI,GACJC,EAAK,GAKLC,EAAM,CAACC,EAAI,KAAO,CACpB,MAAM,IAAI,MAAMA,CAAC,CACrB,EACMC,GAASC,GAAM,OAAOA,GAAM,SAC5BC,GAASC,GAAM,OAAOA,GAAM,SAC5BC,GAAWC,GAAMA,aAAa,YAAe,YAAY,OAAOA,CAAC,GAAKA,EAAE,YAAY,OAAS,aAE7FC,EAAS,CAACD,EAAGE,IAAM,CAACH,GAAQC,CAAC,GAAM,OAAOE,GAAM,UAAYA,EAAI,GAAKF,EAAE,SAAWE,EAClFT,EAAI,qBAAqB,EACzBO,EAEAG,EAAOC,GAAQ,IAAI,WAAWA,CAAG,EACjCC,EAAQC,GAAQ,WAAW,KAAKA,CAAG,EACnCC,GAAO,CAACX,EAAGY,IAAQZ,EAAE,SAAS,EAAE,EAAE,SAASY,EAAK,GAAG,EACnDC,EAAcC,GAAM,MAAM,KAAKT,EAAOS,CAAC,CAAC,EACzC,IAAKC,GAAMJ,GAAKI,EAAG,CAAC,CAAC,EACrB,KAAK,EAAE,EACNC,EAAI,CAAE,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAG,EACjDC,GAAOC,GAAO,CAChB,GAAIA,GAAMF,EAAE,IAAME,GAAMF,EAAE,GACtB,OAAOE,EAAKF,EAAE,GAClB,GAAIE,GAAMF,EAAE,GAAKE,GAAMF,EAAE,EACrB,OAAOE,GAAMF,EAAE,EAAI,IACvB,GAAIE,GAAMF,EAAE,GAAKE,GAAMF,EAAE,EACrB,OAAOE,GAAMF,EAAE,EAAI,GAE3B,EACMG,EAAcC,GAAQ,CACxB,MAAML,EAAI,cACV,GAAI,CAACd,GAAMmB,CAAG,EACV,OAAOvB,EAAIkB,CAAC,EAChB,MAAMM,EAAKD,EAAI,OACTE,EAAKD,EAAK,EAChB,GAAIA,EAAK,EACL,OAAOxB,EAAIkB,CAAC,EAChB,MAAMQ,EAAQhB,EAAIe,CAAE,EACpB,QAASE,EAAK,EAAGC,EAAK,EAAGD,EAAKF,EAAIE,IAAMC,GAAM,EAAG,CAE7C,MAAMC,EAAKT,GAAIG,EAAI,WAAWK,CAAE,CAAC,EAC3BE,EAAKV,GAAIG,EAAI,WAAWK,EAAK,CAAC,CAAC,EACrC,GAAIC,IAAO,QAAaC,IAAO,OAC3B,OAAO9B,EAAIkB,CAAC,EAChBQ,EAAMC,CAAE,EAAIE,EAAK,GAAKC,CAC1B,CACA,OAAOJ,CACX,EAEMK,EAAO,CAACxB,EAAGI,IAAQH,EAAOJ,GAAMG,CAAC,EAAIe,EAAWf,CAAC,EAAIK,EAAKJ,EAAOD,CAAC,CAAC,EAAGI,CAAG,EACzEqB,GAAK,IAAM,YAAY,OACvBC,GAAS,IAAMD,GAAE,GAAI,QAAUhC,EAAI,+BAA+B,EAElEkC,EAAc,IAAIC,IAAS,CAC7B,MAAMC,EAAI1B,EAAIyB,EAAK,OAAO,CAACE,EAAK9B,IAAM8B,EAAM7B,EAAOD,CAAC,EAAE,OAAQ,CAAC,CAAC,EAChE,IAAIQ,EAAM,EACV,OAAAoB,EAAK,QAAQ5B,GAAK,CAAE6B,EAAE,IAAI7B,EAAGQ,CAAG,EAAGA,GAAOR,EAAE,MAAQ,CAAC,EAC9C6B,CACX,EAEME,GAAc,CAAC3B,EAAMb,IACbkC,GAAE,EACH,gBAAgBtB,EAAIC,CAAG,CAAC,EAE/B4B,EAAM,OACNC,EAAS,CAACrC,EAAGsC,EAAKC,EAAKC,EAAM,6BAA+BzC,GAAMC,CAAC,GAAKsC,GAAOtC,GAAKA,EAAIuC,EAAMvC,EAAIH,EAAI2C,CAAG,EAEzGC,EAAI,CAACrC,EAAGU,EAAI1B,IAAM,CACpB,MAAM6C,EAAI7B,EAAIU,EACd,OAAOmB,GAAK,GAAKA,EAAInB,EAAImB,CAC7B,EACMS,GAAQtC,GAAMqC,EAAErC,EAAGf,CAAC,EAGpBsD,GAAS,CAACC,EAAKC,IAAO,EACpBD,IAAQ,IAAMC,GAAM,KACpBhD,EAAI,gBAAkB+C,EAAM,QAAUC,CAAE,EACzC,IAACzC,EAAIqC,EAAEG,EAAKC,CAAE,EAAG/B,EAAI+B,EAAIC,EAAI,GAAYC,EAAI,GAChD,KAAO3C,IAAM,IAAI,CACb,MAAM4C,EAAIlC,EAAIV,EAAG6B,EAAInB,EAAIV,EACnBN,EAAIgD,EAAIC,EAAIC,EAClBlC,EAAIV,EAAGA,EAAI6B,EAAGa,EAAIC,EAAUA,EAAIjD,CACpC,CACA,OAAOgB,IAAM,GAAK2B,EAAEK,EAAGD,CAAE,EAAIhD,EAAI,YAAY,CACjD,EACMoD,GAAYC,GAAS,CAEvB,MAAMC,EAAKC,GAAIF,CAAI,EACnB,OAAI,OAAOC,GAAO,YACdtD,EAAI,UAAYqD,EAAO,UAAU,EAC9BC,CACX,EACME,GAAUC,GAAOA,aAAaC,EAAQD,EAAIzD,EAAI,gBAAgB,EAG9D2D,EAAO,IAAM,KAEbC,EAAN,MAAMA,CAAM,CAOR,YAAYC,EAAIC,EAAIC,EAAIC,EAAI,CAJ5BC,EAAA,WACAA,EAAA,WACAA,EAAA,WACAA,EAAA,WAEI,MAAMvB,EAAMiB,EACZ,KAAK,GAAKnB,EAAOqB,EAAI,GAAInB,CAAG,EAC5B,KAAK,GAAKF,EAAOsB,EAAI,GAAIpB,CAAG,EAC5B,KAAK,GAAKF,EAAOuB,EAAI,GAAIrB,CAAG,EAC5B,KAAK,GAAKF,EAAOwB,EAAI,GAAItB,CAAG,EAC5B,OAAO,OAAO,IAAI,CACtB,CACA,OAAO,WAAWe,EAAG,CACjB,OAAO,IAAIG,EAAMH,EAAE,EAAGA,EAAE,EAAG,GAAIb,EAAEa,EAAE,EAAIA,EAAE,CAAC,CAAC,CAC/C,CAEA,OAAO,UAAUlC,EAAK2C,EAAS,GAAO,CAClC,MAAMC,EAAIvE,EAEJwE,EAASxD,EAAKJ,EAAOe,EAAKzB,CAAC,CAAC,EAE5BuE,EAAW9C,EAAI,EAAE,EACvB6C,EAAO,EAAE,EAAIC,EAAW,KACxB,MAAMC,EAAIC,EAAaH,CAAM,EAI7B5B,EAAO8B,EAAG,GADEJ,EAASP,EAAOpE,CACX,EACjB,MAAMiF,EAAK5B,EAAE0B,EAAIA,CAAC,EACZpB,EAAIN,EAAE4B,EAAK,EAAE,EACbC,EAAI7B,EAAEuB,EAAIK,EAAK,EAAE,EACvB,GAAI,CAAE,QAAAE,EAAS,MAAOzB,CAAC,EAAK0B,GAAQzB,EAAGuB,CAAC,EACnCC,GACD1E,EAAI,uBAAuB,EAC/B,MAAM4E,GAAU3B,EAAI,MAAQ,GACtB4B,GAAiBR,EAAW,OAAU,EAC5C,MAAI,CAACH,GAAUjB,IAAM,IAAM4B,GACvB7E,EAAI,gCAAgC,EACpC6E,IAAkBD,IAClB3B,EAAIL,EAAE,CAACK,CAAC,GACL,IAAIW,EAAMX,EAAGqB,EAAG,GAAI1B,EAAEK,EAAIqB,CAAC,CAAC,CACvC,CAEA,gBAAiB,CACb,MAAM/D,EAAIZ,EACJwE,EAAIvE,EACJ6D,EAAI,KACV,GAAIA,EAAE,IAAG,EACL,MAAM,IAAI,MAAM,iBAAiB,EAGrC,KAAM,CAAE,GAAIqB,EAAG,GAAIC,EAAG,GAAIC,EAAG,GAAIC,CAAC,EAAKxB,EACjCyB,EAAKtC,EAAEkC,EAAIA,CAAC,EACZK,EAAKvC,EAAEmC,EAAIA,CAAC,EACZK,EAAKxC,EAAEoC,EAAIA,CAAC,EACZK,EAAKzC,EAAEwC,EAAKA,CAAE,EACdE,EAAM1C,EAAEsC,EAAK3E,CAAC,EACdgF,EAAO3C,EAAEwC,EAAKxC,EAAE0C,EAAMH,CAAE,CAAC,EACzBK,EAAQ5C,EAAEyC,EAAKzC,EAAEuB,EAAIvB,EAAEsC,EAAKC,CAAE,CAAC,CAAC,EACtC,GAAII,IAASC,EACT,MAAM,IAAI,MAAM,uCAAuC,EAE3D,MAAMC,EAAK7C,EAAEkC,EAAIC,CAAC,EACZW,EAAK9C,EAAEoC,EAAIC,CAAC,EAClB,GAAIQ,IAAOC,EACP,MAAM,IAAI,MAAM,uCAAuC,EAC3D,OAAO,IACX,CAEA,OAAOC,EAAO,CACV,KAAM,CAAE,GAAIC,EAAI,GAAIC,EAAI,GAAIC,CAAE,EAAK,KAC7B,CAAE,GAAIZ,EAAI,GAAIC,EAAI,GAAIC,CAAE,EAAK5B,GAAOmC,CAAK,EACzCI,EAAOnD,EAAEgD,EAAKR,CAAE,EAChBY,EAAOpD,EAAEsC,EAAKY,CAAE,EAChBG,EAAOrD,EAAEiD,EAAKT,CAAE,EAChBc,EAAOtD,EAAEuC,EAAKW,CAAE,EACtB,OAAOC,IAASC,GAAQC,IAASC,CACrC,CACA,KAAM,CACF,OAAO,KAAK,OAAOC,CAAC,CACxB,CAEA,QAAS,CACL,OAAO,IAAIvC,EAAMhB,EAAE,CAAC,KAAK,EAAE,EAAG,KAAK,GAAI,KAAK,GAAIA,EAAE,CAAC,KAAK,EAAE,CAAC,CAC/D,CAEA,QAAS,CACL,KAAM,CAAE,GAAIgD,EAAI,GAAIC,EAAI,GAAIC,CAAE,EAAK,KAC7BvF,EAAIZ,EAEJyG,EAAIxD,EAAEgD,EAAKA,CAAE,EACbS,EAAIzD,EAAEiD,EAAKA,CAAE,EACb1E,EAAIyB,EAAE,GAAKA,EAAEkD,EAAKA,CAAE,CAAC,EACrBQ,EAAI1D,EAAErC,EAAI6F,CAAC,EACXG,EAAOX,EAAKC,EACZW,EAAI5D,EAAEA,EAAE2D,EAAOA,CAAI,EAAIH,EAAIC,CAAC,EAC5BI,EAAIH,EAAID,EACRK,EAAID,EAAItF,EACRwF,EAAIL,EAAID,EACRO,EAAKhE,EAAE4D,EAAIE,CAAC,EACZG,EAAKjE,EAAE6D,EAAIE,CAAC,EACZG,EAAKlE,EAAE4D,EAAIG,CAAC,EACZI,EAAKnE,EAAE8D,EAAID,CAAC,EAClB,OAAO,IAAI7C,EAAMgD,EAAIC,EAAIE,EAAID,CAAE,CACnC,CAEA,IAAInB,EAAO,CACP,KAAM,CAAE,GAAIC,EAAI,GAAIC,EAAI,GAAIC,EAAI,GAAIkB,CAAE,EAAK,KACrC,CAAE,GAAI9B,EAAI,GAAIC,EAAI,GAAIC,EAAI,GAAI6B,CAAE,EAAKzD,GAAOmC,CAAK,EACjDpF,EAAIZ,EACJ,EAAIC,EAEJwG,EAAIxD,EAAEgD,EAAKV,CAAE,EACbmB,EAAIzD,EAAEiD,EAAKV,CAAE,EACbhE,EAAIyB,EAAEoE,EAAK,EAAIC,CAAE,EACjBX,EAAI1D,EAAEkD,EAAKV,CAAE,EACboB,EAAI5D,GAAGgD,EAAKC,IAAOX,EAAKC,GAAMiB,EAAIC,CAAC,EACnCK,EAAI9D,EAAE0D,EAAInF,CAAC,EACXsF,EAAI7D,EAAE0D,EAAInF,CAAC,EACXwF,EAAI/D,EAAEyD,EAAI9F,EAAI6F,CAAC,EACfQ,GAAKhE,EAAE4D,EAAIE,CAAC,EACZG,GAAKjE,EAAE6D,EAAIE,CAAC,EACZG,GAAKlE,EAAE4D,EAAIG,CAAC,EACZI,GAAKnE,EAAE8D,EAAID,CAAC,EAClB,OAAO,IAAI7C,EAAMgD,GAAIC,GAAIE,GAAID,EAAE,CACnC,CAQA,SAAS,EAAGI,EAAO,GAAM,CACrB,GAAI,CAACA,IAAS,IAAM,IAAM,KAAK,IAAG,GAC9B,OAAOf,EAEX,GADA3D,EAAO,EAAG,GAAIhD,CAAC,EACX,IAAM,GACN,OAAO,KACX,GAAI,KAAK,OAAOiH,CAAC,EACb,OAAOU,GAAK,CAAC,EAAE,EAEnB,IAAI1D,EAAI0C,EACJ,EAAIM,EACR,QAAStC,EAAI,KAAM,EAAI,GAAIA,EAAIA,EAAE,OAAM,EAAI,IAAM,GAGzC,EAAI,GACJV,EAAIA,EAAE,IAAIU,CAAC,EACN+C,IACL,EAAI,EAAE,IAAI/C,CAAC,GAEnB,OAAOV,CACX,CAEA,UAAW,CACP,KAAM,CAAE,GAAIR,EAAG,GAAIqB,EAAG,GAAI8C,CAAC,EAAK,KAEhC,GAAI,KAAK,OAAOjB,CAAC,EACb,MAAO,CAAE,EAAG,GAAI,EAAG,EAAE,EACzB,MAAMkB,EAAKvE,GAAOsE,EAAG7H,CAAC,EAEtB,OAAIqD,EAAEwE,EAAIC,CAAE,IAAM,IACdrH,EAAI,iBAAiB,EAElB,CAAE,EAAG4C,EAAEK,EAAIoE,CAAE,EAAG,EAAGzE,EAAE0B,EAAI+C,CAAE,CAAC,CACvC,CACA,SAAU,CACN,KAAM,CAAE,EAAApE,EAAG,EAAAqB,CAAC,EAAK,KAAK,eAAc,EAAG,SAAQ,EACzCrD,EAAIqG,GAAWhD,CAAC,EAEtB,OAAArD,EAAE,EAAE,GAAKgC,EAAI,GAAK,IAAO,EAClBhC,CACX,CACA,OAAQ,CACJ,OAAOD,EAAW,KAAK,SAAS,CACpC,CACA,eAAgB,CACZ,OAAO,KAAK,SAASuB,EAAI1C,EAAC,EAAG,EAAK,CACtC,CACA,cAAe,CACX,OAAO,KAAK,cAAa,EAAG,IAAG,CACnC,CACA,eAAgB,CAEZ,IAAI4D,EAAI,KAAK,SAASjE,EAAI,GAAI,EAAK,EAAE,SACrC,OAAIA,EAAI,KACJiE,EAAIA,EAAE,IAAI,IAAI,GACXA,EAAE,IAAG,CAChB,CACA,OAAO,QAAQlC,EAAK2C,EAAQ,CACxB,OAAON,EAAM,UAAU7B,EAAKR,CAAG,EAAG2C,CAAM,CAC5C,CACA,IAAI,GAAI,CACJ,OAAO,KAAK,SAAQ,EAAG,CAC3B,CACA,IAAI,GAAI,CACJ,OAAO,KAAK,SAAQ,EAAG,CAC3B,CACA,YAAa,CACT,OAAO,KAAK,QAAO,CACvB,CACJ,EA5MID,EADEL,EACK,QACPK,EAFEL,EAEK,QAFX,IAAMF,EAANE,EA+MA,MAAM6C,EAAI,IAAI/C,EAAMjE,GAAIC,GAAI,GAAIkD,EAAEnD,GAAKC,EAAE,CAAC,EAEpCyG,EAAI,IAAIzC,EAAM,GAAI,GAAI,GAAI,EAAE,EAElCA,EAAM,KAAO+C,EACb/C,EAAM,KAAOyC,EACb,MAAMmB,GAAcvE,GAAQzB,EAAWR,GAAK0B,EAAOO,EAAK,GAAIY,CAAI,EAAG5D,CAAE,CAAC,EAAE,QAAO,EACzEwE,EAAgBtD,GAAMsB,EAAI,KAAOvB,EAAWJ,EAAKJ,EAAOS,CAAC,CAAC,EAAE,QAAO,CAAE,CAAC,EACtEsG,EAAO,CAACtE,EAAGuE,IAAU,CAEvB,IAAIpF,EAAIa,EACR,KAAOuE,KAAU,IACbpF,GAAKA,EACLA,GAAK7C,EAET,OAAO6C,CACX,EAEMqF,GAAexE,GAAM,CAEvB,MAAMyE,EADMzE,EAAIA,EAAK1D,EACJ0D,EAAK1D,EAChBoI,EAAMJ,EAAKG,EAAI,EAAE,EAAIA,EAAMnI,EAC3BqI,EAAML,EAAKI,EAAI,EAAE,EAAI1E,EAAK1D,EAC1BsI,EAAON,EAAKK,EAAI,EAAE,EAAIA,EAAMrI,EAC5BuI,EAAOP,EAAKM,EAAK,GAAG,EAAIA,EAAOtI,EAC/BwI,EAAOR,EAAKO,EAAK,GAAG,EAAIA,EAAOvI,EAC/ByI,EAAOT,EAAKQ,EAAK,GAAG,EAAIA,EAAOxI,EAC/B0I,EAAQV,EAAKS,EAAK,GAAG,EAAIA,EAAOzI,EAChC2I,EAAQX,EAAKU,EAAM,GAAG,EAAID,EAAOzI,EACjC4I,EAAQZ,EAAKW,EAAM,GAAG,EAAIL,EAAOtI,EAEvC,MAAO,CAAE,UADUgI,EAAKY,EAAM,EAAE,EAAIlF,EAAK1D,EACrB,GAAAmI,CAAE,CAC1B,EACMU,GAAM,oEAGNzD,GAAU,CAACzB,EAAGuB,IAAM,CACtB,MAAM4D,EAAKzF,EAAE6B,EAAIA,EAAIA,CAAC,EAChB6D,EAAK1F,EAAEyF,EAAKA,EAAK5D,CAAC,EAClB8D,EAAMd,GAAYvE,EAAIoF,CAAE,EAAE,UAChC,IAAIrF,EAAIL,EAAEM,EAAImF,EAAKE,CAAG,EACtB,MAAMC,EAAM5F,EAAE6B,EAAIxB,EAAIA,CAAC,EACjBwF,EAAQxF,EACRyF,EAAQ9F,EAAEK,EAAImF,EAAG,EACjBO,EAAWH,IAAQtF,EACnB0F,EAAWJ,IAAQ5F,EAAE,CAACM,CAAC,EACvB2F,EAASL,IAAQ5F,EAAE,CAACM,EAAIkF,EAAG,EACjC,OAAIO,IACA1F,EAAIwF,IACJG,GAAYC,KACZ5F,EAAIyF,IACH9F,EAAEK,CAAC,EAAI,MAAQ,KAChBA,EAAIL,EAAE,CAACK,CAAC,GACL,CAAE,QAAS0F,GAAYC,EAAU,MAAO3F,CAAC,CACpD,EAEM6F,EAAWC,GAASlG,GAAK0B,EAAawE,CAAI,CAAC,EAC3CC,EAAU,IAAI/I,IAAMsD,GAAI,YAAY,GAAGtD,CAAC,EACxCgJ,EAAU,IAAIhJ,IAAMmD,GAAS,YAAY,EAAE,GAAGnD,CAAC,EAE/CiJ,GAAaC,GAAW,CAE1B,MAAMC,EAAOD,EAAO,MAAM,EAAGrJ,CAAC,EAC9BsJ,EAAK,CAAC,GAAK,IACXA,EAAK,EAAE,GAAK,IACZA,EAAK,EAAE,GAAK,GACZ,MAAMC,EAASF,EAAO,MAAMrJ,EAAGC,CAAE,EAC3BuJ,EAASR,EAAQM,CAAI,EACrBG,EAAQ9C,EAAE,SAAS6C,CAAM,EACzBE,EAAaD,EAAM,UACzB,MAAO,CAAE,KAAAH,EAAM,OAAAC,EAAQ,OAAAC,EAAQ,MAAAC,EAAO,WAAAC,CAAU,CACpD,EAEMC,EAA6BC,GAASV,EAAQjH,EAAK2H,EAAM5J,CAAC,CAAC,EAAE,KAAKoJ,EAAS,EAC3ES,EAAwBD,GAASR,GAAUD,EAAQlH,EAAK2H,EAAM5J,CAAC,CAAC,CAAC,EAEjE8J,GAAqBF,GAASD,EAA0BC,CAAI,EAAE,KAAMjG,GAAMA,EAAE,UAAU,EAEtFoG,GAAgBH,GAASC,EAAqBD,CAAI,EAAE,WACpDI,GAAeC,GAAQf,EAAQe,EAAI,QAAQ,EAAE,KAAKA,EAAI,MAAM,EAC5DC,GAAeD,GAAQA,EAAI,OAAOd,EAAQc,EAAI,QAAQ,CAAC,EACvDE,GAAQ,CAAC/I,EAAGgJ,EAAQvH,IAAQ,CAE9B,KAAM,CAAE,WAAYpD,EAAG,OAAQc,CAAC,EAAKa,EAC/BkB,EAAI0G,EAAQoB,CAAM,EAClBC,EAAI1D,EAAE,SAASrE,CAAC,EAAE,QAAO,EAO/B,MAAO,CAAE,SANQF,EAAYiI,EAAG5K,EAAGoD,CAAG,EAMnB,OALHwG,GAAW,CAEvB,MAAMiB,EAAIvH,GAAKT,EAAI0G,EAAQK,CAAM,EAAI9I,CAAC,EACtC,OAAOG,EAAO0B,EAAYiI,EAAG7C,GAAW8C,CAAC,CAAC,EAAGrK,CAAE,CACnD,CACyB,CAC7B,EAKMsK,GAAY,MAAO1H,EAAK2H,IAAY,CACtC,MAAMrK,EAAI8B,EAAKY,CAAG,EACZ,EAAI,MAAM8G,EAA0Ba,CAAO,EAC3CJ,EAAS,MAAMlB,EAAQ,EAAE,OAAQ/I,CAAC,EACxC,OAAO6J,GAAYG,GAAM,EAAGC,EAAQjK,CAAC,CAAC,CAC1C,EAKMsK,GAAO,CAAC5H,EAAK2H,IAAY,CAC3B,MAAMrK,EAAI8B,EAAKY,CAAG,EACZ,EAAIgH,EAAqBW,CAAO,EAChCJ,EAASjB,EAAQ,EAAE,OAAQhJ,CAAC,EAClC,OAAO+J,GAAYC,GAAM,EAAGC,EAAQjK,CAAC,CAAC,CAC1C,EACMuK,EAAW,CAAE,OAAQ,EAAI,EACzBC,GAAU,CAACC,EAAK/H,EAAKgI,EAAKC,EAAOJ,IAAa,CAChDE,EAAM3I,EAAK2I,EAAK3K,CAAE,EAClB4C,EAAMZ,EAAKY,CAAG,EACdgI,EAAM5I,EAAK4I,EAAK7K,CAAC,EACjB,KAAM,CAAE,OAAAoE,CAAM,EAAK0G,EACnB,IAAIxE,EACA+D,EACA9J,EACAwK,EACAC,EAAW,WAAW,GAAE,EAC5B,GAAI,CACA1E,EAAI1C,EAAM,QAAQiH,EAAKzG,CAAM,EAC7BiG,EAAIzG,EAAM,QAAQgH,EAAI,MAAM,EAAG5K,CAAC,EAAGoE,CAAM,EACzC7D,EAAIkE,EAAamG,EAAI,MAAM5K,EAAGC,CAAE,CAAC,EACjC8K,EAAKpE,EAAE,SAASpG,EAAG,EAAK,EACxByK,EAAW5I,EAAYiI,EAAE,QAAO,EAAI/D,EAAE,QAAO,EAAIzD,CAAG,CACxD,MACc,CAAE,CAWhB,MAAO,CAAE,SAAAmI,EAAU,OAVH3B,GAAW,CAIvB,GAFI0B,GAAM,MAEN,CAAC3G,GAAUkC,EAAE,aAAY,EACzB,MAAO,GACX,MAAM2E,EAAIjC,EAAQK,CAAM,EAExB,OADYgB,EAAE,IAAI/D,EAAE,SAAS2E,EAAG,EAAK,CAAC,EAC3B,IAAIF,EAAG,OAAM,CAAE,EAAE,cAAa,EAAG,KAChD,CACyB,CAC7B,EAEMG,GAAc,MAAO3K,EAAGJ,EAAGwD,EAAGmH,EAAOJ,IAAaV,GAAYW,GAAQpK,EAAGJ,EAAGwD,EAAGmH,CAAI,CAAC,EAEpFK,GAAS,CAAC5K,EAAGJ,EAAGwD,EAAGmH,EAAOJ,IAAaR,GAAYS,GAAQpK,EAAGJ,EAAGwD,EAAGmH,CAAI,CAAC,EAEzErH,GAAM,CACR,YAAa,SAAU2H,IAAa,CAChC,MAAM7K,EAAI4B,GAAM,EACVhC,EAAIiC,EAAY,GAAGgJ,CAAQ,EACjC,OAAOxK,EAAI,MAAML,EAAE,OAAO,UAAWJ,EAAE,MAAM,CAAC,CAClD,EACA,WAAY,OACZ,WAAYe,EACZ,WAAYM,EACZ,YAAaY,EACb,IAAKU,EACL,OAAQE,GACR,YAAaR,EACjB,EAEM6I,GAAQ,CACV,0BAA2B1B,EAC3B,qBAAsBE,EACtB,iBAAkB,IAAMrH,GAAYxC,CAAC,EACrC,WAAY,CAACsL,EAAI,EAAG3H,EAAIgD,KACpBhD,EAAE,SAAS,EAAE,EAENA,EAEf,EAGM4H,EAAI,EACJC,GAAa,IACbC,GAAW,KAAK,KAAKD,GAAaD,CAAC,EAAI,EACvCG,EAAc,IAAMH,EAAI,GACxBI,GAAa,IAAM,CACrB,MAAMC,EAAS,CAAA,EACf,IAAIjI,EAAIgD,EACJxF,EAAIwC,EACR,QAAS2H,EAAI,EAAGA,EAAIG,GAAUH,IAAK,CAC/BnK,EAAIwC,EACJiI,EAAO,KAAKzK,CAAC,EACb,QAAS0K,EAAI,EAAGA,EAAIH,EAAaG,IAC7B1K,EAAIA,EAAE,IAAIwC,CAAC,EACXiI,EAAO,KAAKzK,CAAC,EAEjBwC,EAAIxC,EAAE,OAAM,CAChB,CACA,OAAOyK,CACX,EACA,IAAIE,GAEJ,MAAMC,GAAQ,CAACC,EAAKrI,IAAM,CACtB,MAAMtD,EAAIsD,EAAE,OAAM,EAClB,OAAOqI,EAAM3L,EAAIsD,CACrB,EAYM0D,GAAQhH,GAAM,CAChB,MAAM4L,EAAOH,KAAUA,GAAQH,GAAU,GACzC,IAAIhI,EAAI0C,EACJ6F,EAAIvF,EACR,MAAMwF,EAAU,GAAKZ,EACfa,EAASD,EACTE,EAAO5J,EAAI0J,EAAU,CAAC,EACtBG,EAAU7J,EAAI8I,CAAC,EACrB,QAASD,EAAI,EAAGA,EAAIG,GAAUH,IAAK,CAC/B,IAAIiB,EAAQ,OAAOlM,EAAIgM,CAAI,EAC3BhM,IAAMiM,EACFC,EAAQb,IACRa,GAASH,EACT/L,GAAK,IAET,MAAMmM,EAAMlB,EAAII,EACVe,EAAOD,EACPE,EAAOF,EAAM,KAAK,IAAID,CAAK,EAAI,EAC/BI,EAASrB,EAAI,IAAM,EACnBsB,EAAQL,EAAQ,EAClBA,IAAU,EAEVL,EAAIA,EAAE,IAAIH,GAAMY,EAAQV,EAAKQ,CAAI,CAAC,CAAC,EAGnC9I,EAAIA,EAAE,IAAIoI,GAAMa,EAAOX,EAAKS,CAAI,CAAC,CAAC,CAE1C,CACA,MAAO,CAAE,EAAA/I,EAAG,EAAAuI,EAChB","x_google_ignoreList":[0]}