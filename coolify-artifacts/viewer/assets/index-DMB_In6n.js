var Zt=Object.defineProperty;var _t=(t,n,s)=>n in t?Zt(t,n,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[n]=s;var Z=(t,n,s)=>_t(t,typeof n!="symbol"?n+"":n,s);/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const Rt={p:0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedn,n:0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3edn,h:8n,a:0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffecn,d:0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3n,Gx:0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an,Gy:0x6666666666666666666666666666666666666666666666666666666666666658n},{p:h,n:H,Gx:tt,Gy:nt,a:q,d:G}=Rt,zt=8n,B=32,X=64,b=(t="")=>{throw new Error(t)},St=t=>typeof t=="bigint",rt=t=>typeof t=="string",Tt=t=>t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array",R=(t,n)=>!Tt(t)||typeof n=="number"&&n>0&&t.length!==n?b("Uint8Array expected"):t,U=t=>new Uint8Array(t),V=t=>Uint8Array.from(t),it=(t,n)=>t.toString(16).padStart(n,"0"),N=t=>Array.from(R(t)).map(n=>it(n,2)).join(""),A={_0:48,_9:57,A:65,F:70,a:97,f:102},st=t=>{if(t>=A._0&&t<=A._9)return t-A._0;if(t>=A.A&&t<=A.F)return t-(A.A-10);if(t>=A.a&&t<=A.f)return t-(A.a-10)},k=t=>{const n="hex invalid";if(!rt(t))return b(n);const s=t.length,e=s/2;if(s%2)return b(n);const f=U(e);for(let c=0,r=0;c<e;c++,r+=2){const l=st(t.charCodeAt(r)),i=st(t.charCodeAt(r+1));if(l===void 0||i===void 0)return b(n);f[c]=l*16+i}return f},v=(t,n)=>R(rt(t)?k(t):V(R(t)),n),at=()=>globalThis?.crypto,Xt=()=>at()?.subtle??b("crypto.subtle must be defined"),Y=(...t)=>{const n=U(t.reduce((e,f)=>e+R(f).length,0));let s=0;return t.forEach(e=>{n.set(e,s),s+=e.length}),n},lt=(t=B)=>at().getRandomValues(U(t)),O=BigInt,_=(t,n,s,e="bad number: out of range")=>St(t)&&n<=t&&t<s?t:b(e),o=(t,n=h)=>{const s=t%n;return s>=0n?s:n+s},ut=t=>o(t,H),dt=(t,n)=>{(t===0n||n<=0n)&&b("no inverse n="+t+" mod="+n);let s=o(t,n),e=n,f=0n,c=1n;for(;s!==0n;){const r=e/s,l=e%s,i=f-c*r;e=s,s=l,f=c,c=i}return e===1n?o(f,n):b("no inverse")},Yt=t=>{const n=mt[t];return typeof n!="function"&&b("hashes."+t+" not set"),n},et=t=>t instanceof g?t:b("Point expected"),K=2n**256n,m=class m{constructor(n,s,e,f){Z(this,"ex");Z(this,"ey");Z(this,"ez");Z(this,"et");const c=K;this.ex=_(n,0n,c),this.ey=_(s,0n,c),this.ez=_(e,1n,c),this.et=_(f,0n,c),Object.freeze(this)}static fromAffine(n){return new m(n.x,n.y,1n,o(n.x*n.y))}static fromBytes(n,s=!1){const e=G,f=V(R(n,B)),c=n[31];f[31]=c&-129;const r=M(f);_(r,0n,s?K:h);const i=o(r*r),a=o(i-1n),u=o(e*i+1n);let{isValid:d,value:y}=Ht(a,u);d||b("bad point: y not sqrt");const p=(y&1n)===1n,x=(c&128)!==0;return!s&&y===0n&&x&&b("bad point: x==0, isLastByteOdd"),x!==p&&(y=o(-y)),new m(y,r,1n,o(y*r))}assertValidity(){const n=q,s=G,e=this;if(e.is0())throw new Error("bad point: ZERO");const{ex:f,ey:c,ez:r,et:l}=e,i=o(f*f),a=o(c*c),u=o(r*r),d=o(u*u),y=o(i*n),p=o(u*o(y+a)),x=o(d+o(s*o(i*a)));if(p!==x)throw new Error("bad point: equation left != right (1)");const z=o(f*c),S=o(r*l);if(z!==S)throw new Error("bad point: equation left != right (2)");return this}equals(n){const{ex:s,ey:e,ez:f}=this,{ex:c,ey:r,ez:l}=et(n),i=o(s*l),a=o(c*f),u=o(e*l),d=o(r*f);return i===a&&u===d}is0(){return this.equals(T)}negate(){return new m(o(-this.ex),this.ey,this.ez,o(-this.et))}double(){const{ex:n,ey:s,ez:e}=this,f=q,c=o(n*n),r=o(s*s),l=o(2n*o(e*e)),i=o(f*c),a=n+s,u=o(o(a*a)-c-r),d=i+r,y=d-l,p=i-r,x=o(u*y),z=o(d*p),S=o(u*p),C=o(y*d);return new m(x,z,C,S)}add(n){const{ex:s,ey:e,ez:f,et:c}=this,{ex:r,ey:l,ez:i,et:a}=et(n),u=q,d=G,y=o(s*r),p=o(e*l),x=o(c*d*a),z=o(f*i),S=o((s+e)*(r+l)-y-p),C=o(z-x),Q=o(z+x),$=o(p-u*y),At=o(S*C),gt=o(Q*$),Et=o(S*$),vt=o(C*Q);return new m(At,gt,vt,Et)}multiply(n,s=!0){if(!s&&(n===0n||this.is0()))return T;if(_(n,1n,H),n===1n)return this;if(this.equals(E))return Pt(n).p;let e=T,f=E;for(let c=this;n>0n;c=c.double(),n>>=1n)n&1n?e=e.add(c):s&&(f=f.add(c));return e}toAffine(){const{ex:n,ey:s,ez:e}=this;if(this.equals(T))return{x:0n,y:1n};const f=dt(e,h);return o(e*f)!==1n&&b("invalid inverse"),{x:o(n*f),y:o(s*f)}}toBytes(){const{x:n,y:s}=this.assertValidity().toAffine(),e=yt(s);return e[31]|=n&1n?128:0,e}toHex(){return N(this.toBytes())}clearCofactor(){return this.multiply(O(zt),!1)}isSmallOrder(){return this.clearCofactor().is0()}isTorsionFree(){let n=this.multiply(H/2n,!1).double();return H%2n&&(n=n.add(this)),n.is0()}static fromHex(n,s){return m.fromBytes(v(n),s)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}toRawBytes(){return this.toBytes()}};Z(m,"BASE"),Z(m,"ZERO");let g=m;const E=new g(tt,nt,1n,o(tt*nt)),T=new g(0n,1n,1n,0n);g.BASE=E;g.ZERO=T;const yt=t=>k(it(_(t,0n,K),X)).reverse(),M=t=>O("0x"+N(V(R(t)).reverse())),w=(t,n)=>{let s=t;for(;n-- >0n;)s*=s,s%=h;return s},Ct=t=>{const s=t*t%h*t%h,e=w(s,2n)*s%h,f=w(e,1n)*t%h,c=w(f,5n)*f%h,r=w(c,10n)*c%h,l=w(r,20n)*r%h,i=w(l,40n)*l%h,a=w(i,80n)*i%h,u=w(a,80n)*i%h,d=w(u,10n)*c%h;return{pow_p_5_8:w(d,2n)*t%h,b2:s}},ot=0x2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0n,Ht=(t,n)=>{const s=o(n*n*n),e=o(s*s*n),f=Ct(t*e).pow_p_5_8;let c=o(t*s*f);const r=o(n*c*c),l=c,i=o(c*ot),a=r===t,u=r===o(-t),d=r===o(-t*ot);return a&&(c=l),(u||d)&&(c=i),(o(c)&1n)===1n&&(c=o(-c)),{isValid:a||u,value:c}},F=t=>ut(M(t)),j=(...t)=>mt.sha512Async(...t),D=(...t)=>Yt("sha512Sync")(...t),ht=t=>{const n=t.slice(0,B);n[0]&=248,n[31]&=127,n[31]|=64;const s=t.slice(B,X),e=F(n),f=E.multiply(e),c=f.toBytes();return{head:n,prefix:s,scalar:e,point:f,pointBytes:c}},I=t=>j(v(t,B)).then(ht),W=t=>ht(D(v(t,B))),qt=t=>I(t).then(n=>n.pointBytes),Gt=t=>W(t).pointBytes,bt=t=>j(t.hashable).then(t.finish),pt=t=>t.finish(D(t.hashable)),xt=(t,n,s)=>{const{pointBytes:e,scalar:f}=t,c=F(n),r=E.multiply(c).toBytes();return{hashable:Y(r,e,s),finish:a=>{const u=ut(c+F(a)*f);return R(Y(r,yt(u)),X)}}},Kt=async(t,n)=>{const s=v(t),e=await I(n),f=await j(e.prefix,s);return bt(xt(e,f,s))},Lt=(t,n)=>{const s=v(t),e=W(n),f=D(e.prefix,s);return pt(xt(e,f,s))},J={zip215:!0},wt=(t,n,s,e=J)=>{t=v(t,X),n=v(n),s=v(s,B);const{zip215:f}=e;let c,r,l,i,a=Uint8Array.of();try{c=g.fromHex(s,f),r=g.fromHex(t.slice(0,B),f),l=M(t.slice(B,X)),i=E.multiply(l,!1),a=Y(r.toBytes(),c.toBytes(),n)}catch{}return{hashable:a,finish:d=>{if(i==null||!f&&c.isSmallOrder())return!1;const y=F(d);return r.add(c.multiply(y,!1)).add(i.negate()).clearCofactor().is0()}}},Vt=async(t,n,s,e=J)=>bt(wt(t,n,s,e)),Nt=(t,n,s,e=J)=>pt(wt(t,n,s,e)),mt={sha512Async:async(...t)=>{const n=Xt(),s=Y(...t);return U(await n.digest("SHA-512",s.buffer))},sha512Sync:void 0,bytesToHex:N,hexToBytes:k,concatBytes:Y,mod:o,invert:dt,randomBytes:lt},kt={getExtendedPublicKeyAsync:I,getExtendedPublicKey:W,randomPrivateKey:()=>lt(B),precompute:(t=8,n=E)=>(n.multiply(3n),n)},P=8,Ot=256,Bt=Math.ceil(Ot/P)+1,L=2**(P-1),Ft=()=>{const t=[];let n=E,s=n;for(let e=0;e<Bt;e++){s=n,t.push(s);for(let f=1;f<L;f++)s=s.add(n),t.push(s);n=s.double()}return t};let ct;const ft=(t,n)=>{const s=n.negate();return t?s:n},Pt=t=>{const n=ct||(ct=Ft());let s=T,e=E;const f=2**P,c=f,r=O(f-1),l=O(P);for(let i=0;i<Bt;i++){let a=Number(t&r);t>>=l,a>L&&(a-=c,t+=1n);const u=i*L,d=u,y=u+Math.abs(a)-1,p=i%2!==0,x=a<0;a===0?e=e.add(ft(p,n[d])):s=s.add(ft(x,n[y]))}return{p:s,f:e}};export{Rt as CURVE,g as ExtendedPoint,g as Point,mt as etc,Gt as getPublicKey,qt as getPublicKeyAsync,Lt as sign,Kt as signAsync,kt as utils,Nt as verify,Vt as verifyAsync};
//# sourceMappingURL=index-DMB_In6n.js.map
